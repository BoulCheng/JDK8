- ConcurrentHashMap 并发处理点
    - ConcurrentHashMap 在initTable时使用了cas， 而HashMap对应的操作并没有
    - 在没有哈希冲突时 ConcurrentHashMap 也使用cas， 而HashMap对应的操作并没有
    - 在有哈希冲突时 ConcurrentHashMap synchronized 锁住了链表表头或红黑树根节点， 而HashMap对应的操作并没有
    - HashMap在高并发场景下有数据丢失以及不准确
    - 在强一致的场景中ConcurrentHashMap就不适用，原因是ConcurrentHashMap中的get、size等方法没有用到锁，ConcurrentHashMap是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据
    - 在数据量比较大的时候，链表会转换为红黑树。红黑树在并发情况下，删除和插入过程中有个平衡的过程，会牵涉到大量节点，因此哈希冲突时会用synchronized锁定根节点，竞争锁资源的代价相对比较高。
- ConcurrentSkipListMap 优势
    - 跳表是一种用于快速查询的数据结构，类似于平衡树。它们都可以对元素进行快速查找，但有一个重要的区别就是：对平衡树的插入和删除往往可能导致平衡树进行全局调整，而跳表的插入和删除只需要对整个数据结构的局部进行操作即可。而跳跃表的操作针对局部，需要锁住的节点少，因此在并发场景下的性能会更好一些
      
    - 基于跳表实现
    - 存取大数据量
    - 在非线程安全的Map容器中，基于红黑树实现的TreeMap在单线程中的性能表现得并不比跳跃表差
    
    - 跳跃表
    - 基于链表扩展的特殊链表
    - 横向上有多层有序链表,最底层包含了所有数据,越往上层数据越少
    - 纵向上有索引层
    - 从最顶层开始查询访问，通过判断元素值来缩小查询范围
    - 新增 首先新增一个节点到最底层的链表中，根据概率算出level值，再根据level值新建索引层，最后链接索引层的新节点。新增节点和链接索引都是基于CAS操作实现
    - 删除 首先找到待删除结点，将其value值设置为null；之后再向待删除结点的next位置新增一个标记结点，以便减少并发冲突；然后让待删结点的前驱节点直接指向它的后继结点， 最后判断此次删除后是否导致某一索引层没有其它节点了，并视情况删除该层索引 
- 如果对数据有强一致要求，则需使用Hashtable；在大部分场景通常都是弱一致性的情况下，使用ConcurrentHashMap即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用ConcurrentSkipListMap