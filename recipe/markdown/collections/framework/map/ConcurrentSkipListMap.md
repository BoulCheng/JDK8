### ConcurrentSkipListMap
- 无 synchronized 
- 跳表是一种用于快速查询的数据结构，类似于平衡树。它们都可以对元素进行快速查找，但有一个重要的区别就是：对平衡树的插入和删除往往可能导致平衡树进行全局调整，而跳表的插入和删除只需要对整个数据结构的局部进行操作即可。而跳跃表的操作针对局部，需要锁住的节点少，因此在并发场景下的性能会更好一些

- ConcurrentHashMap
    - 黑树在并发情况下，删除和插入过程中有个平衡的过程，会牵涉到大量节点，因此哈希冲突时会用synchronized锁定根节点，竞争锁资源的代价相对比较高。
    
- 对数据有强一致要求，则需使用Hashtable

- 目前常用的key-value数据结构有三种：Hash表、红黑树、SkipList，它们各自有着不同的优缺点（不考虑删除操作）：

Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。

红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。

SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。

如果要实现一个key-value结构，需求的功能有插入、查找、迭代、修改，那么首先Hash表就不是很适合了，因为迭代的时间复杂度比较高；而红黑树的插入很可能会涉及多个结点的旋转、变色操作，因此需要在外层加锁，这无形中降低了它可能的并发度。而SkipList底层是用链表实现的，可以实现为lock free，同时它还有着不错的性能（单线程下只比红黑树略慢），非常适合用来实现我们需求的那种key-value结构